/*
Strings with long blocks of repeating characters take much less space if kept in a compressed representation.
To obtain the compressed representation, we replace each segment of equal characters in the string with the number of
characters in the segment followed by the character(e.x we replace segment "CCCC" with 4C).
To avoid increasing the size, we leave the one-letter segments unchanged(the compressed representation of "BC" is the same string - "BC").
For example, the compressed representation of the string "ABBBCCDDCCC" is "A3B2C2D3C", and the compressed representation of the string "AAAAAAAAAAABXXAAAAAAAAAA"
is "11AB2X10A". Observe that, in the second example, if we removed the "BXX" segment from the middle of the word,
we would obtain a much shorter compressed representation - "21A".

In order to take advantage of this observation, we decided to modify the compression algorithm.
Now before compression, we remove exactly K consecutive letters from the input string. We would like to know the shortest compressed form
 that we can generate this way.


https://stackoverflow.com/questions/61373619/the-shortest-possible-length-of-the-compressed-representation-of-a-string
*/


function solution($S, $K){
  $strlen = function($arg){
      $pattern = '/(.)\1*/';
      preg_match_all($pattern, $arg, $matched);

      foreach($matched[0] as $m){
              if (strlen($m) > 1) $shortArr[]=strlen($m);
              $shortArr[] = substr($m,0,1);
      }

      $str = implode("",$shortArr);
      return strlen($str);
  };

  $finalLength = $strlen($S);
  for($i=0;$i<strlen($S)-$K;$i++){
      if(!preg_match('/^(.)\1*$/', substr($S,$i,$K))){
          $firstPart = substr($S,0,$i);
          $lastPart = substr($S,$i+$K);
          $length = $strlen($firstPart . $lastPart);
          if ($length < $finalLength) $finalLength = $length;
      }
  }

  return $finalLength;
}